/*    ______      _
 *   / ____/___ _(_)___ ___  ____ _____
 *  / / __/ __ `/ / __ `__ \/ __ `/ __ \
 * / /_/ / /_/ / / / / / / / /_/ / / / /
 * \____/\__,_/_/_/ /_/ /_/\__,_/_/ /_/
 *
 * Code generated by Gaiman version {{VER}}
 * https://gaiman.js.org
 */
function parse_cookies(cookies) {
    const result = {};
    cookies.split(/\s*;\s*/).forEach(function(pair) {
        pair = pair.split(/\s*=\s*/);
        var name = decodeURIComponent(pair[0]);
        var value = decodeURIComponent(pair.splice(1).join('='));
        result[name] = value;
    });
    return result;
}

const loops = {};

const Gaiman = {
    _get_time() {
        return +new Date;
    },
    should_break_loop(id) {
        if (!loops[id]) {
            loops[id] = {
                start: this._get_time(),
                count: 1
            };
            return false;
        } else {
            var now = this._get_time();
            const { start } = loops[id];
            const count = ++loops[id].count;
            if (count > this._config.loop_threshold) {
                const stop = now - start > this._config.loop_timeout;
                if (stop) {
                    window.parent.postMessage({
                        message: 'Infinite Loop detected!',
                        colno: null,
                        lineno: null
                    });
                }
                return stop;
            }
            return false;
        }
    },
    exit_loop(id) {
        delete loops[id];
    },
    parse(input) {
        return $.terminal.parse_arguments(input);
    },
    parse_extra(input) {
        return $.terminal.split_arguments(input);
    }
};


// based on https://stackoverflow.com/a/46282334/387194
function extend(object, prototype) {
    const descriptors = Object.getOwnPropertyDescriptors(object);
    for (const prop in descriptors) {
        Object.defineProperty(prototype, prop, descriptors[prop]);
    }
}

function is_node() {
    return typeof process !== 'undefined' &&
        process.release.name === 'node';
}

const map_supported = 'Map' in this;


function map_dict() {
    return {
        make(init = {}) {
            return new Map(Object.entries(init));
        },
        set(object, ...rest) {
            while (rest.length > 2) {
                const prop = rest.shift();
                if (object instanceof Map) {
                    object = object.get(prop);
                } else {
                    object = object[prop];
                }
            }
            const prop = rest.shift();
            const value = rest.shift();
            if (object instanceof Map) {
                object.set(prop, value);
            } else {
                object[prop] = value;
            }
        },
        get(object, ...rest) {
            while (rest.length) {
                const arg = rest.shift();
                if (object instanceof Map) {
                    object = object.get(arg);
                } else {
                    object = object[arg];
                }
            }
            return object;
        }
    };
}

function simple_dict() {
    return {
        make(init = {}) {
            return init;
        },
        set(object, ...rest) {
            while (rest.length > 2) {
                const prop = rest.shift();
                object = object[prop];
            }
            const prop = rest.shift();
            const value = rest.shift();
            object[prop] = value;
        },
        get(object, ...rest) {
            while (rest.length) {
                const arg = rest.shift();
                object = object[arg];
            }
            return object;
        }
    };
}

function to_string(object) {
    if (object instanceof Array) {
        object = object.map(to_string);
    } else if (typeof object !== 'string') {
        object = String(object);
    }
    return object;
}

const dict = map_supported ? map_dict() : simple_dict();

class WebAdapter {
    constructor(config = {}) {
        this._config = $.extend({
            newline: true,
            loop_threshold: 500,
            loop_timeout: 200
        }, config);
        var body = $('body');
        var options = body.css('--options');
        if (typeof options === 'undefined') {
            options = {};
        } else {
            try {
                options = JSON.parse(options);
            } catch(e) {
                console.warn('Gaiman: Invalid --option CSS variable');
                options = {};
            }
        }
        this._term = body.terminal($.noop, $.extend({
            greetings: false,
            exit: false
        }, options));
    }
    config(name, value) {
        if (typeof name === 'string') {
            this._config[name] = value;
        } else {
            $.extend(this._config, name);
        }
    }
    store(name, ...args) {
        try {
            if (args.length === 0) {
                return JSON.parse(localStorage.getItem(name));
            } else {
                const [ value ] = args;
                localStorage.setItem(name, JSON.stringify(value));
            }
        } catch(e) {
            // ignore errors that may happen in Incognito mode
        }
    }
    sleep(timeout, visible = false) {
        this._term.pause(visible);
        return new Promise(resolve => {
            setTimeout(() => {
                this._term.resume();
                resolve();
            }, Number(timeout));
        });
    }
    sleep_extra(timeout) {
        return this.sleep(timeout, true);
    }
    error(message) {
        this._term.error(message);
    }
    echo(arg) {
        this._term.echo(to_string(arg), { newline: this._config.newline });
    }
    ask(message) {
        return this._term.read(message);
    }
    ask_extra(message, delay) {
        return this._term.read(message, { typing: true, delay });
    }
    echo_extra(string, delay) {
        return this._term.echo(string, { typing: true, delay });
    }
    prompt_extra(string, delay) {
        return this._term.set_prompt(string, { typing: true, delay });
    }
    input_extra(string, delay) {
        return this._term.typing('enter', delay, string);
    }
    post(url, data = {}) {
        const form = new FormData();
        Object.entries(data).forEach(([key, value]) => {
            form.append(key, value);
        });
        return fetch(url, {
            method: 'POST',
            body: form
        }).then(res => res.text());
    }
    get(url) {
        return fetch(url).then(res => res.text());
    }
}

extend(Gaiman, WebAdapter.prototype);

(function(map) {
   Array.prototype.map = function(...args) {
       var result = map.apply(this, args);
       var is_promise = result.some(x => x && x.then);
       if (is_promise) {
           return Promise.all(result); 
       } else {
           return result;
       }
   };
})(Array.prototype.map);

var cookie, argv, gaiman, $$__m;
if (is_node()) {
    argv = process.argv;
} else {
    cookie = parse_cookies(document.cookie);
    gaiman = new WebAdapter();
}
